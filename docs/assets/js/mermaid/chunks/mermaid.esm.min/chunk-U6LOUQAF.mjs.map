{
  "version": 3,
  "sources": ["../../../src/utils/subGraphTitleMargins.ts", "../../../src/utils/lineWithOffset.ts"],
  "sourcesContent": ["import type { FlowchartDiagramConfig } from '../config.type.js';\n\nexport const getSubGraphTitleMargins = ({\n  flowchart,\n}: {\n  flowchart: FlowchartDiagramConfig;\n}): {\n  subGraphTitleTopMargin: number;\n  subGraphTitleBottomMargin: number;\n  subGraphTitleTotalMargin: number;\n} => {\n  const subGraphTitleTopMargin = flowchart?.subGraphTitleMargin?.top ?? 0;\n  const subGraphTitleBottomMargin = flowchart?.subGraphTitleMargin?.bottom ?? 0;\n  const subGraphTitleTotalMargin = subGraphTitleTopMargin + subGraphTitleBottomMargin;\n\n  return {\n    subGraphTitleTopMargin,\n    subGraphTitleBottomMargin,\n    subGraphTitleTotalMargin,\n  };\n};\n", "import type { EdgeData, Point } from '../types.js';\n\n// We need to draw the lines a bit shorter to avoid drawing\n// under any transparent markers.\n// The offsets are calculated from the markers' dimensions.\nconst markerOffsets = {\n  aggregation: 18,\n  extension: 18,\n  composition: 18,\n  dependency: 6,\n  lollipop: 13.5,\n  arrow_point: 4,\n} as const;\n\n/**\n * Calculate the deltas and angle between two points\n * @param point1 - First point\n * @param point2 - Second point\n * @returns The angle, deltaX and deltaY\n */\nfunction calculateDeltaAndAngle(\n  point1?: Point | [number, number],\n  point2?: Point | [number, number]\n): { angle: number; deltaX: number; deltaY: number } {\n  if (point1 === undefined || point2 === undefined) {\n    return { angle: 0, deltaX: 0, deltaY: 0 };\n  }\n  point1 = pointTransformer(point1);\n  point2 = pointTransformer(point2);\n  const [x1, y1] = [point1.x, point1.y];\n  const [x2, y2] = [point2.x, point2.y];\n  const deltaX = x2 - x1;\n  const deltaY = y2 - y1;\n  return { angle: Math.atan(deltaY / deltaX), deltaX, deltaY };\n}\n\nconst pointTransformer = (data: Point | [number, number]) => {\n  if (Array.isArray(data)) {\n    return { x: data[0], y: data[1] };\n  }\n  return data;\n};\n\nexport const getLineFunctionsWithOffset = (\n  edge: Pick<EdgeData, 'arrowTypeStart' | 'arrowTypeEnd'>\n) => {\n  return {\n    x: function (\n      this: void,\n      d: Point | [number, number],\n      i: number,\n      data: (Point | [number, number])[]\n    ) {\n      let offset = 0;\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        // Handle first point\n        // Calculate the angle and delta between the first two points\n        const { angle, deltaX } = calculateDeltaAndAngle(data[0], data[1]);\n        // Calculate the offset based on the angle and the marker's dimensions\n        offset =\n          markerOffsets[edge.arrowTypeStart as keyof typeof markerOffsets] *\n          Math.cos(angle) *\n          (deltaX >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        // Handle last point\n        // Calculate the angle and delta between the last two points\n        const { angle, deltaX } = calculateDeltaAndAngle(\n          data[data.length - 1],\n          data[data.length - 2]\n        );\n        offset =\n          markerOffsets[edge.arrowTypeEnd as keyof typeof markerOffsets] *\n          Math.cos(angle) *\n          (deltaX >= 0 ? 1 : -1);\n      }\n      return pointTransformer(d).x + offset;\n    },\n    y: function (\n      this: void,\n      d: Point | [number, number],\n      i: number,\n      data: (Point | [number, number])[]\n    ) {\n      // Same handling as X above\n      let offset = 0;\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        const { angle, deltaY } = calculateDeltaAndAngle(data[0], data[1]);\n        offset =\n          markerOffsets[edge.arrowTypeStart as keyof typeof markerOffsets] *\n          Math.abs(Math.sin(angle)) *\n          (deltaY >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        const { angle, deltaY } = calculateDeltaAndAngle(\n          data[data.length - 1],\n          data[data.length - 2]\n        );\n        offset =\n          markerOffsets[edge.arrowTypeEnd as keyof typeof markerOffsets] *\n          Math.abs(Math.sin(angle)) *\n          (deltaY >= 0 ? 1 : -1);\n      }\n      return pointTransformer(d).y + offset;\n    },\n  };\n};\n\nif (import.meta.vitest) {\n  const { it, expect, describe } = import.meta.vitest;\n  describe('calculateDeltaAndAngle', () => {\n    it('should calculate the angle and deltas between two points', () => {\n      expect(calculateDeltaAndAngle([0, 0], [0, 1])).toStrictEqual({\n        angle: 1.5707963267948966,\n        deltaX: 0,\n        deltaY: 1,\n      });\n      expect(calculateDeltaAndAngle([1, 0], [0, -1])).toStrictEqual({\n        angle: 0.7853981633974483,\n        deltaX: -1,\n        deltaY: -1,\n      });\n      expect(calculateDeltaAndAngle({ x: 1, y: 0 }, [0, -1])).toStrictEqual({\n        angle: 0.7853981633974483,\n        deltaX: -1,\n        deltaY: -1,\n      });\n      expect(calculateDeltaAndAngle({ x: 1, y: 0 }, { x: 1, y: 0 })).toStrictEqual({\n        angle: NaN,\n        deltaX: 0,\n        deltaY: 0,\n      });\n    });\n\n    it('should calculate the angle and deltas if one point in undefined', () => {\n      expect(calculateDeltaAndAngle(undefined, [0, 1])).toStrictEqual({\n        angle: 0,\n        deltaX: 0,\n        deltaY: 0,\n      });\n      expect(calculateDeltaAndAngle([0, 1], undefined)).toStrictEqual({\n        angle: 0,\n        deltaX: 0,\n        deltaY: 0,\n      });\n    });\n  });\n}\n"],
  "mappings": "yCAEO,IAAMA,EAA0BC,EAAA,CAAC,CACtC,UAAAC,CACF,IAMK,CACH,IAAMC,EAAyBD,GAAW,qBAAqB,KAAO,EAChEE,EAA4BF,GAAW,qBAAqB,QAAU,EACtEG,EAA2BF,EAAyBC,EAE1D,MAAO,CACL,uBAAAD,EACA,0BAAAC,EACA,yBAAAC,CACF,CACF,EAlBuC,2BCGvC,IAAMC,EAAgB,CACpB,YAAa,GACb,UAAW,GACX,YAAa,GACb,WAAY,EACZ,SAAU,KACV,YAAa,CACf,EAQA,SAASC,EACPC,EACAC,EACmD,CACnD,GAAID,IAAW,QAAaC,IAAW,OACrC,MAAO,CAAE,MAAO,EAAG,OAAQ,EAAG,OAAQ,CAAE,EAE1CD,EAASE,EAAiBF,CAAM,EAChCC,EAASC,EAAiBD,CAAM,EAChC,GAAM,CAACE,EAAIC,CAAE,EAAI,CAACJ,EAAO,EAAGA,EAAO,CAAC,EAC9B,CAACK,EAAIC,CAAE,EAAI,CAACL,EAAO,EAAGA,EAAO,CAAC,EAC9BM,EAASF,EAAKF,EACdK,EAASF,EAAKF,EACpB,MAAO,CAAE,MAAO,KAAK,KAAKI,EAASD,CAAM,EAAG,OAAAA,EAAQ,OAAAC,CAAO,CAC7D,CAdSC,EAAAV,EAAA,0BAgBT,IAAMG,EAAmBO,EAACC,GACpB,MAAM,QAAQA,CAAI,EACb,CAAE,EAAGA,EAAK,CAAC,EAAG,EAAGA,EAAK,CAAC,CAAE,EAE3BA,EAJgB,oBAOZC,EAA6BF,EACxCG,IAEO,CACL,EAAGH,EAAA,SAEDI,EACAC,EACAJ,EACA,CACA,IAAIK,EAAS,EACb,GAAID,IAAM,GAAK,OAAO,OAAOhB,EAAec,EAAK,cAAc,EAAG,CAGhE,GAAM,CAAE,MAAAI,EAAO,OAAAT,CAAO,EAAIR,EAAuBW,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EAEjEK,EACEjB,EAAcc,EAAK,cAA4C,EAC/D,KAAK,IAAII,CAAK,GACbT,GAAU,EAAI,EAAI,GACvB,SAAWO,IAAMJ,EAAK,OAAS,GAAK,OAAO,OAAOZ,EAAec,EAAK,YAAY,EAAG,CAGnF,GAAM,CAAE,MAAAI,EAAO,OAAAT,CAAO,EAAIR,EACxBW,EAAKA,EAAK,OAAS,CAAC,EACpBA,EAAKA,EAAK,OAAS,CAAC,CACtB,EACAK,EACEjB,EAAcc,EAAK,YAA0C,EAC7D,KAAK,IAAII,CAAK,GACbT,GAAU,EAAI,EAAI,GACvB,CACA,OAAOL,EAAiBW,CAAC,EAAE,EAAIE,CACjC,EA7BG,KA8BH,EAAGN,EAAA,SAEDI,EACAC,EACAJ,EACA,CAEA,IAAIK,EAAS,EACb,GAAID,IAAM,GAAK,OAAO,OAAOhB,EAAec,EAAK,cAAc,EAAG,CAChE,GAAM,CAAE,MAAAI,EAAO,OAAAR,CAAO,EAAIT,EAAuBW,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EACjEK,EACEjB,EAAcc,EAAK,cAA4C,EAC/D,KAAK,IAAI,KAAK,IAAII,CAAK,CAAC,GACvBR,GAAU,EAAI,EAAI,GACvB,SAAWM,IAAMJ,EAAK,OAAS,GAAK,OAAO,OAAOZ,EAAec,EAAK,YAAY,EAAG,CACnF,GAAM,CAAE,MAAAI,EAAO,OAAAR,CAAO,EAAIT,EACxBW,EAAKA,EAAK,OAAS,CAAC,EACpBA,EAAKA,EAAK,OAAS,CAAC,CACtB,EACAK,EACEjB,EAAcc,EAAK,YAA0C,EAC7D,KAAK,IAAI,KAAK,IAAII,CAAK,CAAC,GACvBR,GAAU,EAAI,EAAI,GACvB,CACA,OAAON,EAAiBW,CAAC,EAAE,EAAIE,CACjC,EAzBG,IA0BL,GA5DwC",
  "names": ["getSubGraphTitleMargins", "__name", "flowchart", "subGraphTitleTopMargin", "subGraphTitleBottomMargin", "subGraphTitleTotalMargin", "markerOffsets", "calculateDeltaAndAngle", "point1", "point2", "pointTransformer", "x1", "y1", "x2", "y2", "deltaX", "deltaY", "__name", "data", "getLineFunctionsWithOffset", "edge", "d", "i", "offset", "angle"]
}
